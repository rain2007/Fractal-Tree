import java.awt.*;
import java.util.ArrayList;

/**
 * Generator class for generating fractal data
 *
 * @author Raingsey Tevy
 * @version 2024-12-05
 */
public class FractalGenerator implements FractalSubject{

    /** list storing all fractal elements generated by the FractalGenerator */
    private final ArrayList<FractalElement> fractalElementsArrayList;
    /** list of observers that are registered to receive updates */
    ArrayList<FractalObserver> observers;
    /** int array of slider */
    private int[] sliderInfo;
    /** array of color objects for trunk and leaf branches */
    private Color[] colorInfo;

    /**
     * Creates a fractal generator object
     */
    public FractalGenerator() {
        fractalElementsArrayList = new ArrayList<>();
        observers = new ArrayList<>();
    }

    /**
     * Signals all registered observers
     */
    @Override
    public void notifyObservers() {
        for (FractalObserver observer : observers) {
            observer.update();
        }
    }

    /**
     * Adds observer to subject
     *
     * @param obs observer to be added
     */
    @Override
    public void registerObserver(FractalObserver obs) {
        observers.add(obs);
    }

    /**
     * Removes observer from the subject
     *
     * @param obs observer to be removed
     */
    @Override
    public void unregisterObserver(FractalObserver obs) {
        observers.remove(obs);
    }

    /**
     * Sets the values obtained from the gui
     *
     * @param sliderInfo    array of int values obtained from sliders
     * @param colorInfo     array of colors
     */
    @Override
    public void setOptions(int[] sliderInfo, Color[] colorInfo) {
        this.sliderInfo = sliderInfo;
        this.colorInfo = colorInfo;
        notifyObservers();
    }

    /**
     * Retrieves an ArrayList of fractal elements
     *
     * @return an ArrayList of fractal elements
     */
    @Override
    public ArrayList<FractalElement> getFractalElements() {
        fractalElementsArrayList.clear();

        int incrementRed = (colorInfo[1].getRed()-colorInfo[0].getRed())/sliderInfo[0];
        int incrementGreen = (colorInfo[1].getGreen()-colorInfo[0].getGreen())/sliderInfo[0];
        int incrementBlue = (colorInfo[1].getBlue()-colorInfo[0].getBlue())/sliderInfo[0];

        addBranchAndPrepChildren(375,750,375,750-sliderInfo[4],
                sliderInfo[1], sliderInfo[5], sliderInfo[4], -90, sliderInfo[0],
                colorInfo[0].getRed(), colorInfo[0].getGreen(), colorInfo[0].getBlue(),
                incrementRed, incrementGreen, incrementBlue);

        return fractalElementsArrayList;
    }

    /**
     * Recursive helper method for generating fractal elements and preparing child branches.
     *
     * @param x1                  starting x-coordinate of the branch
     * @param y1                  starting y-coordinate of the branch
     * @param x2                  ending x-coordinate of the branch
     * @param y2                  ending y-coordinate of the branch
     * @param childToParentRatio  percentage of the child's width to its parent
     * @param trunkWidth          width of the current branch
     * @param trunkLength         length of the current branch
     * @param previousAngle       angle of the parent branch
     * @param recursionDepth      remaining depth of recursion; stops when it reaches 0
     * @param red                 red component of the branch color
     * @param green               green component of the branch color
     * @param blue                blue component of the branch color
     * @param incrementRed        amount to increase the red color component for child branches for every recursive call
     * @param incrementGreen      amount to increase the green color component for child branches for every recursive call
     * @param incrementBlue       amount to increase the blue color component for child branches for every recursive call
     */
    private void addBranchAndPrepChildren(int x1, int y1, int x2, int y2, float childToParentRatio,
                                          float trunkWidth, float trunkLength, double previousAngle, int recursionDepth,
                                          int red, int green, int blue, int incrementRed, int incrementGreen, int incrementBlue) {
        // Base case
        if (recursionDepth <= 0) {
            return;
        }

        Branch branch = new Branch(x1, y1, x2, y2, trunkWidth, red, green, blue);
        fractalElementsArrayList.add(branch);

        recursionDepth--;
        float childWidth = trunkWidth * (childToParentRatio/100);
        float childLength = trunkLength * (childToParentRatio/100);

        // calculate left branch angle and coordinates
        double leftAngle = previousAngle - sliderInfo[2];
        int xLeftEndPoint = (int) (x2 + childLength * Math.cos(Math.toRadians(leftAngle)));
        int yLeftEndPoint = (int) (y2 + childLength * Math.sin(Math.toRadians(leftAngle)));
        addBranchAndPrepChildren(x2, y2, xLeftEndPoint, yLeftEndPoint,
                childToParentRatio, childWidth, childLength, leftAngle, recursionDepth,
                red + incrementRed, green + incrementGreen, blue + incrementBlue,
                incrementRed, incrementGreen, incrementBlue);

        // calculate right branch angle and coordinates
        double rightAngle = previousAngle + sliderInfo[3];
        int xRightEndPoint = (int) (x2 + childLength * Math.cos(Math.toRadians(rightAngle)));
        int yRightEndPoint = (int) (y2 + childLength * Math.sin(Math.toRadians(rightAngle)));
        addBranchAndPrepChildren(x2, y2, xRightEndPoint, yRightEndPoint,
                childToParentRatio, childWidth, childLength, rightAngle, recursionDepth,
                red + incrementRed, green + incrementGreen, blue + incrementBlue,
                incrementRed, incrementGreen, incrementBlue);
    }

}
